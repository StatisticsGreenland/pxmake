#' Regular expression to parse header in pxfile
#'
#' @returns A character vector
get_px_metadata_regex <- function() {
  paste0("(?<keyword>[[:upper:]-]+)",    # Leading keyword
         "(?:\\[)?",                     # Maybe opening language bracket [
         "(?<language>[[:alpha:]_-]+)?", # Maybe language
         "(?:\\])?",                     # Maybe closing language bracket ]
         "(?:\\(\")?",                   # Maybe opening sub-key parentheses (
         "(?<variable>[^\"]+)?",         # Maybe sub-key
         "(?:\",\")?",                   # Maybe comma before cell value
         "(?<cell>[^\"]+)?",             # Maybe cell value (used by PRECISION)
         "(?:\")?",                      # Maybe closing " after cell value
         "(?:\"\\))?",                   # Maybe closing sub-key parentheses )
         "=",                            # definitely =
         "(?<value>[^;]*)",              # Value is everything up to ending ;
         "(?:;$)?"                       # Maybe ;
  )
}

#' Get encoding listed in px file
#'
#' Encoding is listed in CODEPAGE.
#'
#' @inheritParams read_px_file
#'
#' @returns Character
get_encoding_from_px_file <- function(px_path) {
  encoding <-
    px_path %>%
    readLines(warn = FALSE) %>%
    paste(collapse = '\n') %>%
    stringr::str_extract('(?<=CODEPAGE=").+(?=";)')

  if (is.na(encoding)) {
    encoding <- get_default_encoding()
  }

  return(encoding)
}

#' Get px file content as lines
#'
#' @param px_path Path to a px file
#'
#' @returns A character vector
read_px_file <- function(px_path) {
  file_connection <- file(px_path, encoding = get_encoding_from_px_file(px_path))
  lines <- readLines(con = file_connection, warn = FALSE)
  close(file_connection)

  return(lines)
}

#' Get metdata df from px lines
#'
#' @param px_lines A character vector with the header of a px file.
#'
#' @returns A data frame
get_metdata_df_from_px_lines <- function(px_lines) {
  px_lines %>%
    # Remove newlines in file. Use semi-colon as line separator
    paste0(collapse = "") %>%
    stringr::str_split(";") %>%
    unlist() %>%
    stringr::str_match(get_px_metadata_regex()) %>%
    magrittr::extract(,-1) %>% # remove full match column
    dplyr::as_tibble() %>%
    # remove leading and trailing "
    dplyr::mutate(value = stringr::str_replace_all(value, '^"|"$', '')) %>%
    # remove double quotes caused by collapsing values spanning multiple lines
    dplyr::mutate(value = stringr::str_replace_all(value, '""', '')) %>%
    dplyr::mutate(value = stringr::str_split(value, '","')) %>%
    dplyr::mutate(language = tidyr::replace_na(language, get_main_language(.)),
                  main_language = language == get_main_language(.)
    )
}

#' Create an Excel metadata workbook from a px-file
#'
#' Turn a px-file into an Excel metadata workbook. If pxmake() is run on that
#' workbook it turns back into an equivalent px-file.
#'
#' @inheritParams read_px_file
#' @param xlsx_path Path to save xlsx file at
#' @param rds_data_path Path to save data cube as rds file. If NULL the data
#' cube is added in the 'Data' sheet in the Excel metadata workbook.
#' @param overwrite_xlsx Should existing metadata workbook be overwritten?
#'
#' @returns Nothing
#'
#' @export
metamake <- function(px_path,
                     xlsx_path,
                     rds_data_path = NULL,
                     overwrite_xlsx = TRUE) {

  px_lines <- read_px_file(px_path)

  data_line_index <- stringr::str_which(px_lines, '^DATA=$')

  error_if_not_exactly_one_data_line(data_line_index)

  metadata_lines <- px_lines[c(1:data_line_index)]
  data_lines     <- px_lines[c((data_line_index+1):length(px_lines))]

  metadata_df <- get_metdata_df_from_px_lines(metadata_lines)

  head_stub <-
    metadata_df %>%
    dplyr::filter(keyword %in% c("HEADING", "STUB")) %>%
    tidyr::unnest(value) %>%
    dplyr::rename(long_name = value) %>%
    dplyr::group_by(keyword, language) %>%
    dplyr::mutate(index = dplyr::row_number()) %>%
    dplyr::ungroup() %>%
    dplyr::select(keyword, language, main_language, long_name, index)

  # Use VARIABLECODE if it exists
  variablecode <-
    metadata_df %>%
    dplyr::filter(keyword == "VARIABLECODE", main_language) %>%
    tidyr::unnest(value) %>%
    dplyr::select(variable = value,
                  long_name = variable
                  )

  variable_and_long_name <-
    head_stub %>% ## add figures variable
    dplyr::filter(main_language) %>%
    dplyr::select(-language, -main_language) %>%
    dplyr::full_join(variablecode, by = "long_name") %>%
    # Use long_name in main langauge as VARIABLECODE if it's missing
    dplyr::mutate(variable = ifelse(is.na(variable), long_name, variable)) %>%
    dplyr::select(-long_name) %>%
    dplyr::full_join(head_stub,
                     by = c("keyword", "index"),
                     multiple = "all"
                     )

  heading_vars <-
    variable_and_long_name %>%
    dplyr::filter(main_language, keyword == "HEADING") %>%
    dplyr::pull(variable)

  stub_vars <-
    variable_and_long_name %>%
    dplyr::filter(main_language, keyword == "STUB") %>%
    dplyr::pull(variable)

  position <-
    variable_and_long_name %>%
    tidyr::drop_na(index) %>%
    dplyr::mutate(position = paste0(substr(keyword, 1, 1), index)) %>%
    dplyr::distinct(position, variable)

  name_relation <-
    variable_and_long_name %>%
    dplyr::distinct(variable, language, long_name)

  figures_var <-
    variable_and_long_name %>%
    dplyr::filter(is.na(keyword)) %>%
    dplyr::distinct(variable) %>%
    dplyr::pull(variable)

  if (identical(figures_var, character(0))) {
    figures_var <- "figures_"
  }

  metadata <-
    metadata_df %>%
    dplyr::rename(long_name = variable) %>%
    dplyr::left_join(name_relation, by = c("language", "long_name"))


  ### Make metadata sheet: 'Variables'
  long_name <-
    name_relation %>%
    tidyr::drop_na(language) %>%
    tidyr::pivot_wider(names_from = language,
                       names_glue = "{language}_long_name",
                       values_from = long_name
    )

  note_elimination_domain <-
    metadata %>%
    dplyr::filter(keyword %in% c("NOTE", "ELIMINATION", "DOMAIN")) %>%
    dplyr::select(keyword, language, variable, value) %>%
    tidyr::unnest(value) %>%
    tidyr::pivot_wider(names_from = c(language, keyword),
                       names_glue = "{language}_{tolower(keyword)}",
                       values_from = value
    )

  time_var <-
    metadata %>%
    dplyr::filter(keyword == "TIMEVAL", main_language) %>%
    dplyr::pull(variable)

  if (identical(time_var, character(0))) {
    time_variable_df <- data.frame(variable = character(0))
  } else {
    time_variable_df <- data.frame(variable = time_var, type = "time")
  }

  sheet_variables <-
    position %>%
    dplyr::left_join(time_variable_df, by = "variable") %>%
    dplyr::left_join(long_name, by = "variable") %>%
    dplyr::left_join(note_elimination_domain, by = "variable") %>%
    dplyr::bind_rows(data.frame(variable = figures_var, type = "figures"))


  ### Make metadata sheet: 'Codelists'
  codes <-
    metadata %>%
    dplyr::filter(main_language, keyword %in% c("CODES"),
                  !variable %in% time_variable_df #Time vars are not in codelist
    ) %>%
    tidyr::unnest(value) %>%
    dplyr::rename(code = value) %>%
    dplyr::group_by(variable) %>%
    dplyr::mutate(sortorder = dplyr::row_number()) %>%
    dplyr::ungroup() %>%
    dplyr::select(variable, code, sortorder)

  precision <-
    metadata %>%
    dplyr::filter(keyword == "PRECISION") %>%
    tidyr::unnest(value) %>%
    dplyr::rename(value = cell, precision = value) %>%
    dplyr::select(variable, value, precision)

  values <-
    metadata %>%
    dplyr::filter(keyword %in% c("VALUES")) %>%
    tidyr::unnest(value) %>%
    dplyr::group_by(variable, language) %>%
    dplyr::mutate(sortorder = dplyr::row_number()) %>%
    dplyr::select(variable, value, language, main_language, sortorder)

  codes_and_values <-
    codes %>%
    # Use values as codes, if codes are missing
    dplyr::full_join(values, by = c("variable", "sortorder"), multiple = "all") %>%
    dplyr::mutate(code = ifelse(is.na(code), value, code))

  sheet_codelist <-
    codes_and_values %>%
    dplyr::select(-main_language) %>%
    dplyr::filter(!variable %in% time_var) %>%
    dplyr::left_join(precision, by = c("variable", "value")) %>%
    tidyr::pivot_wider(names_from = language, names_glue = "{language}_code_label") %>%
    dplyr::relocate(precision, .after = last_col())

  ### Make metadata sheet: 'Table'
  sheet_table <-
    metadata %>%
    dplyr::left_join(get_px_keywords(), by = "keyword") %>%
    dplyr::filter(in_table_sheet) %>%
    # Exclude variable specific NOTE
    dplyr::filter(!(keyword == "NOTE" & !is.na(variable))) %>%
    dplyr::rowwise() %>%
    dplyr::mutate(value = paste(value, collapse = ','),
                  keyword = ifelse(language_dependent,
                                   paste0(keyword, "_", language),
                                   keyword
                  )
    ) %>%
    dplyr::select(keyword, value)

  ### Make metadata sheet: 'Data'

  # Order: s1, s2, ..., h1, h2, ...
  expand_order <-
    head_stub %>%
    dplyr::filter(main_language) %>%
    dplyr::mutate(keyword_order = dplyr::case_when(keyword == "STUB" ~ 1,
                                                   keyword == "HEADING" ~ 2,
                                                   TRUE ~ NA
                                                   )
                  ) %>%
    dplyr::arrange(dplyr::across(c(keyword_order, index))) %>%
    dplyr::mutate(expand_order = dplyr::row_number()) %>%
    dplyr::left_join(name_relation, by = c("language", "long_name")) %>%
    dplyr::select(variable, expand_order)

  stub_and_heading_values <-
    codes_and_values %>%
    dplyr::filter(main_language, variable %in% c(heading_vars, stub_vars)) %>%
    dplyr::group_by(variable) %>%
    dplyr::summarise(code = list(code)) %>%
    dplyr::left_join(expand_order, by = "variable") %>%
    dplyr::arrange(expand_order) %>%
    dplyr::select(variable, code) %>%
    tibble::deframe()

  figures <-
    data_lines %>%
    stringr::str_replace_all(";", "") %>%
    stringr::str_split(" ") %>%
    unlist() %>%
    stringr::str_subset("^$", negate = TRUE) %>%
    tibble::enframe(name = NULL, value = figures_var)

  sheet_data <-
    do.call(tidyr::expand_grid, stub_and_heading_values) %>%
    dplyr::bind_cols(figures)

  ### Make sheets in workbook
  wb <- openxlsx::createWorkbook()

  add_sheet <- function(df, sheet_name) {
    openxlsx::addWorksheet(wb,sheet_name, gridLines = FALSE)
    openxlsx::setColWidths(wb, sheet_name, cols = 1:ncol(df), widths = 'auto')
    openxlsx::writeDataTable(wb, sheet_name, df, tableStyle = "TableStyleLight9")
  }

  add_sheet(sheet_table,     "Table")
  add_sheet(sheet_variables, "Variables")
  add_sheet(sheet_codelist,  "Codelists")

  if (is.null(rds_data_path)) {
    error_if_too_many_rows_for_excel(sheet_data)

    add_sheet(sheet_data, "Data")
  } else {
    saveRDS(sheet_data, rds_data_path)
  }

  openxlsx::saveWorkbook(wb, xlsx_path, overwrite = overwrite_xlsx)
}
