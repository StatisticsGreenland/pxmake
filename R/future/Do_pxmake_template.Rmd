---
title: "Pxmake template"
author: "LarsP"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
#install.packages(("pxweb"))
library(pxweb)
library(jsonlite)

```

## Pxmake, do template

Executing this RMarkdown creates a first version of the Excel spreadsheet, that holds all metadata needed to convert a dataframe to a px-file, with pxmake:

pxmake(source-rds-data, meta-data-xlsx. px-file-name)

Before being ready to use the pxmake package, you have allready created a Dataframe, that meets the required specification.

As example for this template creator, a Dataframe from the Greenlandic Statbank is extracted

```{r getdata, echo=FALSE, warning=FALSE, message=FALSE}

px_data <- 
  pxweb_get(url = "https://bank.stat.gl/api/v1/en/Greenland/BE/BE80/BE8020/BEXCALCS.px",
      query =   list("year of birth" = c("*"),
       "place of birth"   = c("N","S"),
       "population"=c("P"),
       "sex"=c("M","F"),
       "time"=c("*"))
) %>% 
  as.data.frame(
    column.name.type = "code",                           variable.value.type = "code"
                            ) %>% 
  select(cohort=`year of birth`,
         pob=`place of birth`,
         measure=population,
         sex,
         time,
         value=`Population Estimates`) %>% 
  mutate(cohort=strtoi(cohort),
         time=strtoi(time),
         age=time-cohort-1) %>% 
  filter(age>=0 & age <= 100) %>% 
  select(pob,measure,age,time,cohort,sex,value) %>% 
  drop_na(value) %>% 
  arrange(pob,measure,age,time,cohort,sex)

px_tidydata <- px_data %>% uncount(value)


head(px_data)

head(px_tidydata)

```

Pretend that it is this dataset you want to convert to a px-file, to be presented with Pxweb/Pxwin/Pxedit

Metadata in a pxfile can be in one or multiple languages and at Statistics Greenland the language information is in

LANGUAGE="en"; LANGUAGES="en","da","kl";

We have chosen English as main language for all px-files to avoid possible issues using nordic characters (ÆæØøÅ)in the Danish alfabet

```{r languages, echo=FALSE, warning=FALSE, message=FALSE}

# setup for Statistics Greenland:

mainlanguage <- "English"
mainlanguage_code <- tolower("en")

multilanguage1 <- "Dansk"
multilanguage1_code <- tolower("da")

multilanguage2 <- "Kalaallisut"
multilanguage2_code <- tolower("kl")

LANGUAGE <- "en"
LANGUAGES <- c("en","da","kl")

```


```{r getpx, echo=FALSE, warning=FALSE, message=FALSE}


# Download px-fil BEXSTA
px_fil <- 
  pxweb_get(url = "https://bank.stat.gl/api/v1/da/Greenland/BE/BE01/BE0120/BEXSTA.px",
            query = '{"query": [
            {"code": "place of birth",
            "selection": {"filter": "all","values": ["*"]}},
            {"code": "gender",
            "selection": {"filter": "all","values": ["*"]}},
            {"code": "age",
            "selection": {"filter": "all","values": ["*"]}},
            {"code": "residence type",
            "selection": {"filter": "all","values": ["*"]}},
            {"code": "time",
            "selection": {"filter": "top","values": ["1"]}}],
            "response": {"format": "px"}}'
            )


```


##Variables & codelists

First we need language labels for the variables, but also for the codes used for all variables in the px_data file.

If lucky we can steal and reuse allready translated items in a Statbank.

pob = place of birth age sex time

cohort meassure

sex, place of birth, age and time are included in a vast number of tables found in Statbank Greenland. To reuse texts, you need to specify what Statbank and what table you want what variable

Any Pxweb statbank can be used. There are some minor differences, and sample code will be added in next chunk

```{r Var_Codelists, echo=FALSE, warning=FALSE, message=FALSE}

 
varget <- function(matrix, lang){
  
  repository <- statbank |> glue::glue()
  tmp        <- glue::glue("{repository}?query={matrix}") |> jsonlite::fromJSON()
  varipx     <- glue::glue("{repository}{tmp$path}/{tmp$id}") |> jsonlite::fromJSON()
  
  varipx |> pluck("variables") |> as_tibble() |> unnest(everything())

}


#Statbank

#Internal StatGreenland
#statbank <- "http://testbank.stat.gl/api/v1/{lang}/Greenland"
#Secure
#statbank <- "https://sikkerbank.stat.gl/api/v1/{lang}/Greenland"
#Public
statbank <- "https://bank.stat.gl/api/v1/{lang}/Greenland"

#Languages
lang <- c("en", "da", "kl") |> set_names()


time <- lang |> 
  map_dfr(~ varget("BEXSTA", .x), .id = "langcode") |>
  select(langcode, code, text, values, valueTexts) |> 
  filter(code %in% c("time"))

pob <- lang |> 
  map_dfr(~ varget("BEXSTA", .x), .id = "langcode") |>
  select(langcode, code, text, values, valueTexts) |> 
  filter(code %in% c("place of birth"))

sex <- lang |> 
  map_dfr(~ varget("BEXSTC", .x), .id = "langcode") |>
  select(langcode, code, text, values, valueTexts) |> 
  filter(code %in% c("gender"))

age <- lang |> 
  map_dfr(~ varget("BEXSTD", .x), .id = "langcode") |>
  select(langcode, code, text, values, valueTexts) |> 
  filter(code %in% c("age"))




# statbank.Hagstova.fo 
# 
# statbank <- "https://statbank.hagstova.fo//api/v1/{lang}/H2"
# lang <- c("en", "fo") |> set_names()
# 
# event <- lang |> 
#   map_dfr(~ varget("Lexis.px", .x), .id = "langcode") |>
#   select(langcode, code, text, values, valueTexts) |> 
#   filter(code %in% c("event"))


#add residence to codelists

head(pob)

head(sex)

head(age)


```

```{r Variables, echo=FALSE, warning=FALSE, message=FALSE}

timevar <- time %>% distinct(langcode,code,text) %>%
  mutate(var=code,
         code=paste0(langcode,"_",code)) %>% 
  select(-1) %>% 
  pivot_wider(names_from = code,values_from = text)

agevar <- age %>% distinct(langcode,code,text) %>%
  mutate(var=code,
         code=paste0(langcode,"_",code)) %>% 
  select(-1) %>% 
  pivot_wider(names_from = code,values_from = text)

pobvar <- pob %>% distinct(langcode,code,text) %>%
  mutate(var=code,
         code=paste0(langcode,"_",code)) %>% 
  select(-1) %>% 
  pivot_wider(names_from = code,values_from = text)

sexvar <- sex %>% distinct(langcode,code,text) %>%
  mutate(var=code,
         code=paste0(langcode,"_",code)) %>% 
  select(-1) %>% 
  pivot_wider(names_from = code,values_from = text)

variables <-  tibble::tribble(
  ~position, ~variable, ~en_long_name, ~da_long_name, ~kl_long_name, ~type, ~en_note, ~da_note, ~kl_note, ~en_elimination, ~da_elimination, ~kl_elimination, ~en_domain, ~da_domain, ~kl_domain,                    "",timevar$var,timevar$en_time,timevar$da_time,timevar$kl_time,"time","en_note","da_note","kl_note","en_elimination","da_elimination","kl_elimination","en_domain","da_domain","kl_domain",                    "",agevar$var,agevar$en_age,agevar$da_age,agevar$kl_age,"2MD","en_note","da_note","kl_note","en_elimination","da_elimination","kl_elimination","en_domain","da_domain","kl_domain",
"",sexvar$var,sexvar$en_time,sexvar$da_sex,sexvar$kl_sex,"2MD","en_note","da_note","kl_note","en_elimination","da_elimination","kl_elimination","en_domain","da_domain","kl_domain",
"",pobvar$var,pobvar$en_pob,pobvar$da_pob,pobvar$kl_pob,"2MD","en_note","da_note","kl_note","en_elimination","da_elimination","kl_elimination","en_domain","da_domain","kl_domain"
)


library(openxlsx)

# Codelists & General not done yet
list_of_datasets <- list("Variables" = variables, "Codelists" = variables, "General" = variables)
write.xlsx(list_of_datasets, file = "meta.xlsx")



time <- lang |> 
  map_dfr(~ varget("BEXSTA", .x), .id = "langcode") |>
  select(langcode, code, text, values, valueTexts) |> 
  filter(code %in% c("time"))

pob <- lang |> 
  map_dfr(~ varget("BEXSTA", .x), .id = "langcode") |>
  select(langcode, code, text, values, valueTexts) |> 
  filter(code %in% c("place of birth"))

sex <- lang |> 
  map_dfr(~ varget("BEXSTC", .x), .id = "langcode") |>
  select(langcode, code, text, values, valueTexts) |> 
  filter(code %in% c("gender"))

age <- lang |> 
  map_dfr(~ varget("BEXSTD", .x), .id = "langcode") |>
  select(langcode, code, text, values, valueTexts) |> 
  filter(code %in% c("age"))




# statbank.Hagstova.fo 
# 
# statbank <- "https://statbank.hagstova.fo//api/v1/{lang}/H2"
# lang <- c("en", "fo") |> set_names()
# 
# event <- lang |> 
#   map_dfr(~ varget("Lexis.px", .x), .id = "langcode") |>
#   select(langcode, code, text, values, valueTexts) |> 
#   filter(code %in% c("event"))


#add residence to codelists

head(pob)

head(sex)

head(age)


```

In Pxweb/Pxwin pxfiles are grouped by Subject. Each pxfile therefore holds needed information as SUBJECT-CODE/SUBJECT-AREA, where SUBJECT-AREA is the presented language specific text. To make sure, to get the right translation/spelling, you only specify the repository and the SUBEJCT-CODE

```{r subject_code, echo=FALSE, warning=FALSE, message=FALSE}


subjectget <- function(lang) {
    subarea <- fromJSON(glue::glue(repository))
    return(subarea)
  }

repository <- "https://bank.stat.gl/api/v1/{lang}/Greenland"
lang <- c("en","da","kl")


subject_area <- lang %>% map_df(~ subjectget(.x),.id="langcode") %>%
    filter(id=="BE")

print(subject_area)

```

General keywords for Stat.

CHARSET="ANSI/utf8"; PXVERSION

```{r charset, echo=FALSE, warning=FALSE, message=FALSE}

# setup for Statistics Greenland:

CHARSET <- "ANSI"



```

```{r Do_General, echo=FALSE, warning=FALSE, message=FALSE}

sheet_General <- tibble::tribble(
                                 ~keyword, ~value,
                                "CHARSET",      CHARSET,
                           "AXIS-VERSION",      "2000",
                               "LANGUAGE",      LANGUAGE,
                              "LANGUAGES",      LANGUAGES,
                          "CREATION-DATE",      FALSE,
                            "NEXT-UPDATE",      FALSE,
                              "PX-SERVER",      FALSE,
                         "DIRECTORY-PATH",      FALSE
)
                         
#sheet_General_lang <- tibble::tribble(
#                                 ~keyword, ~en_value, ~da_value, ~kl_value)
                                


```

The tidy dataset that has to be described with metadata has x variables. Some of these can be reused from existing tables

the variable pob is 'place of birth' and can be found in many tables, here from BEXSTA

the variable sex is found as gender, also from BEXSTC

the variable age is from BEXSTD
